---
date: 2020-07-29 19:00:00
layout: post
title: "CIS 194 11 Applicative functors, Part II 適用函子，第二部分"
subtitle: 
description: 
image: 
optimized_image: 
category: CIS 194 spring 2013
tags:
  - CIS 194 spring 2013
  - Haskell
author: CWKSC
paginate: false
math: true
---

Source: [11-applicative2](https://www.seas.upenn.edu/~cis194/spring13/lectures/11-applicative2.html)

> Translation not finish

## ▌Applicative functors, Part II 適用函子，第二部分

CIS 194 第 11 週
2012 年 4 月 1 日

建議閱讀：

- [Applicative Functors](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors) from Learn You a Haskell
- [The Typeclassopedia](http://www.haskell.org/haskellwiki/Typeclassopedia)

我們首先回顧`Functor`和`Applicative`類：

```
class Functor f where
  fmap :: (a -> b) -> f a -> f b

class Functor f => Applicative f where
  pure  :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
```

每個`Applicative`也是一個-那麼`Functor`我們可以`fmap`根據`pure`和實施`(<*>)`嗎？我們試試吧！

```
fmap g x = pure g <*> x
```

好吧，至少具有正確的類型！但是，不難想像對於某種類型的make `Functor`和`Applicative`instance使得這種相等性不成立。由於這將是一個相當可疑的情況，因此我們將這種平等規定為一條*法律*，這是一種正式的方式，表明給定類型的`Functor`和`Applicative`實例必須“很好地配合”。

現在，讓我們看看更多實例示例`Applicative`。

## ▌更多應用示例

**清單**

`Applicative`for列表的實例如何？實際上有兩種可能的實例：一種將元素列表的函數列表和參數列表匹配（即，將它們“壓縮”在一起），另一種實例以所有可能的方式組合函數和參數。

首先，讓我們編寫執行所有可能組合的實例。（出於下週將變得清楚的原因，這是默認實例。）從這個角度來看，列表代表不確定性：也就是說，類型的值`[a]`可以被認為是具有多種可能性的單個值。然後`(<*>)`對應於不確定性函數應用程序，即，將不確定性函數應用於不確定性參數。

```
instance Applicative [] where
  pure a        = [a]          -- a "deterministic" value
  [] <*> _      = []
  (f:fs) <*> as = (map f as) ++ (fs <*> as)
```

這是一個例子：

```
names  = ["Joe", "Sara", "Mae"]
phones = ["555-5555", "123-456-7890", "555-4321"]

employees1 = Employee <$> names <*> phones
```

也許這個特定的例子沒有多大意義，但不難想像您想以各種可能的方式組合事物的情況。例如，我們可以像這樣進行非確定性算法：

```
(.+) = liftA2 (+)    -- addition lifted to some Applicative context
(.*) = liftA2 (*)    -- same for multiplication

-- nondeterministic arithmetic
n = ([4,5] .* pure 2) .+ [6,1] -- (either 4 or 5) times 2, plus either 6 or 1

-- and some possibly-failing arithmetic too, just for fun
m1 = (Just 3 .+ Just 5) .* Just 8
m2 = (Just 3 .+ Nothing) .* Just 8
```

接下來，讓我們編寫執行元素合併的實例。首先，我們必須回答一個重要的問題：我們應該如何處理不同長度的列表？一些想法表明，最明智的做法是將較長的列表截短為較短的列表，丟棄多餘的元素。當然，還有其他可能的答案：例如，我們可以通過複製最後一個元素來擴展較短的列表（但是，當其中一個列表為空時，我們該怎麼辦？）；或使用“ neutral”元素擴展較短的列表（但隨後我們將需要`Monoid`為該應用程序提供的實例或額外的“ default”參數）。

反過來，這個決定決定了我們必須如何執行`pure`，因為我們必須遵守法律

```
pure f <*> xs === f <$> xs
```

請注意，右側是長度與列表相同的列表`xs`，通過應用`f`到中的每個元素形成`xs`。我們可以使左側結果相同的唯一方法是…… `pure`創建的無限多個副本`f`，因為我們事先不知道`xs`會持續多久。

我們使用`newtype`包裝器實現實例，以將其與其他列表實例區分開。標準的前奏功能`zipWith`也很方便。

```
newtype ZipList a = ZipList { getZipList :: [a] }
  deriving (Eq, Show, Functor)

instance Applicative ZipList where
  pure = ZipList . repeat
  ZipList fs <*> ZipList xs = ZipList (zipWith ($) fs xs)
```

一個例子：

```
employees2 = getZipList $ Employee <$> ZipList names <*> ZipList phones
```

**讀者/環境**

讓我們為做一個最後的示例實例`(->) e`。這被稱為*閱讀器*或適用於*環境的*應用程序，因為它允許從“環境”中“讀取” `e`。實現實例並不難，我們只需要使用鼻子並遵循以下類型：

```
instance Functor ((->) e) where
  fmap = (.)

instance Applicative ((->) e) where
  pure = const
  f <*> x = \e -> (f e) (x e)
```

一個`Employee`例子：

```
data BigRecord = BR { getName         :: Name
                    , getSSN          :: String
                    , getSalary       :: Integer
                    , getPhone        :: String
                    , getLicensePlate :: String
                    , getNumSickDays  :: Int
                    }

r = BR "Brent" "XXX-XX-XXX4" 600000000 "555-1234" "JGX-55T3" 2

getEmp :: BigRecord -> Employee
getEmp = Employee <$> getName <*> getPhone

ex01 = getEmp r
```

## ▌撇開：抽象層次

`Functor`是一個漂亮的工具，但相對簡單。乍看之下，似乎`Applicative`並沒有增加太多`Functor`，但事實證明，這只是一小部分，具有巨大的影響。`Applicative`（我們將在下週看到`Monad`）應該被稱為“計算模型”，而`Functor`事實並非如此。

當處理諸如`Applicative`和時`Monad`，請務必記住涉及*多個層次的抽象*。粗略地說，*抽像*是一種*隱藏*較低級別*細節*的東西，它提供了一個“高級”接口，可以（理想情況下）使用該接口，而無需考慮較低級別—儘管較低級別的細節通常會“洩漏”在某些情況下。抽象層的想法很普遍。考慮一下用戶程序-OS-內核-集成電路-門-矽或HTTP-TCP-IP-以太網，或編程語言-字節碼-彙編-機器代碼。如我們所見，Haskell為我們提供了許多不錯的工具，可用於*在Haskell程序本身中*構造多層抽象，也就是說，我們可以向上動態擴展“編程語言”層堆棧。這是一個強大的功能，但可能導致混亂。人們必須學會明確地能夠在多個層次上思考，並在各個層次之間進行切換。

對於`Applicative`和`Monad`特別，只有兩個層面去關注。第一個是實施各種水平`Applicative`和`Monad`實例，*即* “原始的Haskell”電平。當您實現的`Applicative`實例時，您在以前的家庭作業中獲得了該級別的經驗`Parser`。

一旦有了`Applicative`類型為的實例`Parser`，關鍵是我們可以*使用**接口* “向上移動層”並使用`Parser`s *進行`Applicative`編程*，而無需考慮如何實際實現實例`Parser`及其`Applicative`實例的細節。您在上週的家庭作業中對此有了一點經驗，並且本週將獲得更多的經驗。與實際實現實例相比，在此級別進行編程具有完全不同的感覺。讓我們看一些例子。

## ▌適用的API

擁有統一接口的好處之一`Applicative`是我們可以編寫適用於*任何*類型的通用工具和控制結構的實例`Applicative`。作為第一個示例，讓我們嘗試編寫

```
pair :: Applicative f => f a -> f b -> f (a,b)
```

`pair`接受兩個值並將它們配對，但是都在some的上下文中`Applicative f`。第一次嘗試，我們可以使用一個函數來配對並使用`(<$>)`and 將其移至參數上`(<*>)`：

```
pair fa fb = (\x y -> (x,y)) <$> fa <*> fb
```

儘管我們可以簡化一點，但這是可行的。首先，請注意，Haskell允許使用特殊語法`(,)`來表示對構造函數，因此我們可以編寫

```
pair fa fb = (,) <$> fa <*> fb
```

但是實際上，我們之前已經看過這種模式-這是使`liftA2`我們沿著整`Applicative`條道路起步的模式。所以我們可以進一步簡化為

```
pair fa fb = liftA2 (,) fa fb
```

但是現在無需顯式寫出函數參數，因此我們可以達到最終的簡化版本：

```
pair = liftA2 (,)
```

現在，此功能有什麼作用？當然，這取決於`f`所選的特定對象。讓我們考慮一些特定的例子：

- `f = Maybe`：結果是`Nothing`兩個參數中的任意一個為；如果兩者都是`Just`結果就是`Just`他們的配對。
- `f = []`：`pair`計算兩個列表的笛卡爾乘積。
- `f = ZipList`：`pair`與標準`zip`功能相同。
- `f = IO`：依次`pair`執行兩個`IO`操作，並返回一對結果。
- `f = Parser`：`pair`依次運行兩個解析器（解析器使用輸入的連續部分），並成對返回其結果。如果任何一個解析器失敗，那麼整個事情就會失敗。

可以實現以下功能嗎？考慮一下`f`用上述每種類型替換時每個函數的功能。

```
(*>)       :: Applicative f => f a -> f b -> f b
mapA       :: Applicative f => (a -> f b) -> ([a] -> f [b])
sequenceA  :: Applicative f => [f a] -> f [a]
replicateA :: Applicative f => Int -> f a -> f [a]
```