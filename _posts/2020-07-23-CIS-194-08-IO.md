---
date: 2020-07-23 19:00:00
layout: post
title: "CIS 194 08 IO 輸入輸出"
subtitle: 
description: 
image: 
optimized_image: 
category: CIS 194 spring 2013
tags:
  - CIS 194 spring 2013
  - Haskell
author: CWKSC
paginate: false
math: true
---

Source: [08-IO](https://www.seas.upenn.edu/~cis194/spring13/lectures/08-IO.html)

> Translation not finish

## ▌IO 輸入輸出

CIS 194 第 8 週
2013 年 3 月 11 日

建議閱讀：

- [LYAH Chapter 9: Input and Output](http://learnyouahaskell.com/input-and-output)
- [RWH Chapter 7: I/O](http://book.realworldhaskell.org/read/io.html)

## ▌The problem with purity 純度問題

請記住，Haskell 是*懶惰的 (lazy)*，因此是 *純粹 (pure)*。這意味著兩件事：

1. 函數可能沒有任何外部影響。例如，某個函數可能無法在屏幕上打印任何內容。函數只能計算其輸出
2. 函數可能不取決於外部因素。例如，它們可能無法從鍵盤，文件系統或網絡讀取。函數可能僅取決於其輸入，換句話說，函數每次都應為相同的輸入提供相同的輸出

但是 — 有時候我們 *確實* 希望能夠做這樣的事情！如果使用 Haskell 唯一可以做的事情是編寫函數，然後我們可以在 ghci 提示符下對其進行評估，那麼從理論上講這很有趣，但實際上沒有用

實際上，使用 Haskell 可以做這些事情，但是看起來與大多數其他語言完全不同

## ▌The `IO` type / `IO` 類型

解決難題的方法是一種稱為 `IO` 的特殊類型。 `IO a` 類型的值是對有效計算 (effectful computations) 的描述，如果執行這些計算，（可能）將執行一些有效的 `I/O` 操作，並最終產生 `a` 類型的值。 這裡有一個間接的水平，對於理解這一點至關重要。 `IO a` 類型的值本身本身就是一種惰性的，完全安全的東西，沒有任何影響。 這只是對有效計算的描述。 認為它是一種一流的命令式程序

舉例來說，假設您有

```haskell
c :: Cake
```

你有什麼？為什麼，當然是美味的蛋糕。乾淨利落。

![img](https://www.seas.upenn.edu/~cis194/spring13/static/cake.jpg)

相比之下，假設您有

```
r :: Recipe Cake
```

你有什麼？一塊蛋糕？不，你有一些*說明*如何做蛋糕，只是對一些書面的紙張。

![img](https://www.seas.upenn.edu/~cis194/spring13/static/recipe.gif)

不僅您實際上沒有蛋糕，僅擁有食譜對其他任何事物都沒有影響。只需將食譜握在手中，就不會導致烤箱變熱或麵粉灑在地板上或任何類似的東西上。要真正製作蛋糕，必須*遵循*食譜（導致麵粉撒出，配料混合，烤箱變熱*等*）。

![img](https://www.seas.upenn.edu/~cis194/spring13/static/fire.jpg)

同樣，類型`IO a`值只是產生類型值的“配方” `a`（可能會產生一些影響）。像任何其他值一樣，它可以作為參數傳遞，作為函數的輸出返回，存儲在數據結構中，或者（如我們將很快看到的）與其他`IO`值組合成更複雜的配方。

那麼，`IO a`實際上如何執行類型的值？只有一種方法：Haskell編譯器尋找特殊值

```
main :: IO ()
```

實際上將被交給運行時系統並執行。而已！將Haskell運行時系統想像成是一位主廚，他是唯一可以做飯的廚師。

![img](https://www.seas.upenn.edu/~cis194/spring13/static/chef.jpg)

如果您希望遵循自己的食譜，那麼最好將其作為大食譜（`main`）的一部分，交給大廚。當然，`main`可以任意複雜，並且通常由許多較小的`IO`計算組成。

因此，讓我們編寫第一個實際的可執行的Haskell程序！我們可以使用功能

```
putStrLn :: String -> IO ()
```

給定一個`String`，它返回一個`IO`計算結果（執行後）`String`在屏幕上打印出來。因此，我們只需將其放入一個名為`Hello.hs`：

```
main = putStrLn "Hello, Haskell!"
```

然後`runhaskell Hello.hs`在命令行提示符下鍵入，導致我們的消息被打印到屏幕上！我們還可以`ghc --make Hello.hs`用來生成一個稱為`Hello`（或`Hello.exe`在Windows上）的可執行版本。

## ▌沒有`String`“內部”`IO String`

許多新的Haskell用戶最終會問諸如“我有一個`IO String`，如何將其變成一個`String`？”或“如何`String`擺脫一個`IO String`”之類的問題？根據上述直覺，應該清楚這些是無意義的問題：type的值`IO String`是對某種計算的描述，一個*配方*，用於生成一個`String`。有沒有`String`“內部”的`IO String`，不是有一個蛋糕一個蛋糕食譜“內部”了。要生產`String`（或美味的蛋糕），需要實際*執行*計算（或配方）。唯一的方法是通過將其（可能是更大`IO`值的一部分）提供給Haskell運行時系統`main`。

## ▌結合 `IO`

到現在應該很清楚了，我們需要一種*將* `IO`計算合併為更大的方法。

合併兩個`IO`計算的最簡單方法是使用`(>>)`運算符（發音為“ and then”），其類型為

```
(>>) :: IO a -> IO b -> IO b
```

這簡單地創建了一個`IO`計算，該計算包括按順序運行兩個輸入計算。注意，第一次計算的結果被丟棄；我們只關心它的*作用*。例如：

```
main = putStrLn "Hello" >> putStrLn "world!"
```

這對於“執行此操作；做這個; 這樣做”，結果並不重要。但是，通常這是不夠的。如果我們不想丟棄第一次計算的結果怎麼辦？

解決這種情況的第一個嘗試可能是擁有某種類型的東西`IO a -> IO b -> IO (a,b)`。但是，這也不足夠。原因是我們希望第二個計算能夠*依賴*於第一個計算的結果。例如，假設我們要從用戶那裡讀取一個整數，然後打印出比他們輸入的整數多一個的整數。在這種情況下，第二次計算（在屏幕上打印一些數字）將根據第一次的結果而有所不同。

相反，有一個運算符`(>>=)`（發音為“ bind”），其類型為

```
(>>=) :: IO a -> (a -> IO b) -> IO b
```

首先這可能很難纏住你的頭！`(>>=)`需要將產生類型的值的運算`a`，和一個*功能*，其到達*計算*基於類型的該中間值的第二計算`a`。結果`(>>=)`是（對a的描述）計算，該計算執行第一個計算，使用其結果來確定下一步要執行的操作，然後執行該操作。

例如，我們可以編寫一個程序來讀取用戶的號碼並打印出其後繼者。請注意，我們使用的`readLn :: Read a => IO a`是從用戶讀取輸入並將其轉換為的任何類型的計算的計算`Read`。

```
main :: IO ()
main = putStrLn "Please enter a number: " >> (readLn >>= (\n -> putStrLn (show (n+1))))
```

當然，這看起來很醜陋，但是有更好的編寫方法，我們將在以後討論。

## ▌記錄語法

*該材料未在講課中介紹，但作為完成作業8的額外資源提供。*

假設我們有一個數據類型，例如

```
data D = C T1 T2 T3
```

我們還可以使用*記錄語法*聲明此數據類型，如下所示：

```
data D = C { field1 :: T1, field2 :: T2, field3 :: T3 }
```

我們不僅為存儲在構造函數中的每個字段指定類型，而且為其指定*名稱*`C`。這個新版本的`D`可以與舊版本完全相同的方式使用（特別是我們仍然可以對`D`as 類型的值進行構造和模式匹配`C v1 v2 v3`）。但是，我們還有其他好處。

1. 每個字段名稱自動是一個*投影函數*，該*函數*從type的值中獲取該字段的值`D`。例如，`field2`是一個函數類型

   ```
   field2 :: D -> T2
   ```

   以前，我們將不得不`field2`通過編寫代碼來實現自己

   ```
   field2 (C _ f _) = f
   ```

   如果我們具有許多字段的數據類型，那麼這將消除很多樣板！

2. 除了用於此類值的常規語法外，還有一種特殊的語法可用於*構造*，*修改*和對類型的值進行*模式匹配*`D`。

   我們可以使用如下語法來*構造*類型的值`D`

   ```
   C { field3 = ..., field1 = ..., field2 = ... }
   ```

   用`...`正確類型的表達式填充。請注意，我們可以按任何順序指定字段。

   假設我們有一個價值`d :: D`。我們可以使用如下語法進行*修改* `d`

   ```
   d { field3 = ... }
   ```

   當然，通過“修改”，我們並不是要真正地變異`d`，而是構造一個新的類型值，該類型值與新字段`D`相同，`d`只是用`field3`給定值替換了字段。

   最後，我們可以像這樣對類型的值進行*模式匹配*`D`：

   ```
   foo (C { field1 = x }) = ... x ...
   ```

   這僅`field1`與`D`值中的字段匹配，然後調用它`x`（當然，`x`也可以放置任意模式），而忽略其他字段。